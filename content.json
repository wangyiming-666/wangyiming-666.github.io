{"meta":{"title":"小鸣的PHP","subtitle":"","description":"","author":"小鸣的PHP","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Tags","text":"","path":"tags/index.html","date":"11-04","excerpt":""}],"posts":[{"title":"解决vue路由重复跳转报错","text":"在vue路由重复跳转或者使用路由守卫后控制台会报如下错误 可以在vue-cli的路由route文件夹中的index.js的文件夹插入插入如下代码 1234567891011121314151617181920const router = new VueRouter(&#123; routes&#125;)// 屏蔽加了路由守卫以后的错误const originalPush = VueRouter.prototype.push;const originalReplace = VueRouter.prototype.replace;VueRouter.prototype.push = function push (location, onResolve, onReject) &#123; if (onResolve || onReject) return originalPush.call(this, location, onResolve, onReject) return originalPush.call(this, location).catch(err =&gt; err)&#125;VueRouter.prototype.replace = function replace (location, onResolve, onReject) &#123; if (onResolve || onReject) return originalReplace.call(this, location, onResolve, onReject) return originalReplace.call(this, location).catch(err =&gt; &#123; // console.log(err) return err &#125;)&#125;;export default router","path":"2020/10/30/解决vue路由重复跳转报错/","date":"10-30","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"v-if与v-show的区别","text":"123&lt;h1 v-if='isShow'&gt;我是h1 v-if&lt;/h1&gt;&lt;h1 v-show='isShow'&gt;我是h1 v-show&lt;/h1&gt; 异同点 1234567891011121314151617v-if 和 v-show 的异同点1. 相同点 : 可以切换元素的显示与隐藏2. 不同点 : 切换显示和隐藏的实现不同 v-if : 显示:创建节点 隐藏: 删除节点 v-show : 显示: display:block 隐藏 : display:none3. 使用场景 : v-if因为要不断的创建和删除来切换显示与隐藏 ,所以性能不高 v-if : 切换次数不频繁的时候, v-show : 切换次数频繁的时候","path":"2020/10/22/v-if与v-show的区别/","date":"10-22","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"node服务器允许跨域","text":"请求node服务器时console控制台出现如下错误 需要向请求头部写入允许跨域 1234567891011const http = require('http')const server = http.createServer()server.on('request',(req,res)=&gt;&#123; res.writeHead(200, &#123; 'Content-type': `text/plain;charset=utf-8`, \"Access-Control-Allow-Origin\": \"http://127.0.0.1:5500\" &#125;); res.end('hellow')&#125;)server.listen(8080)","path":"2020/10/20/node服务器允许跨域/","date":"10-20","excerpt":"","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"git提交文件","text":"在学习git的过程中我觉得还是有很多知识点需要整理的首先我们要在项目的文件夹下面初始化一个 本地仓库 运行命令 1git init 可以看到 在我们的文件夹下面生成了一个.git文件 这个文件夹是在window看不到的 需要打开隐藏文件才可以看到 这里不建议去动这个文件 然后我们在文件夹下面建一个index.php文件 并添加点内容 12&lt;?phpecho \"现在的时间是:\".date('Y-m-d H:i:s'); 然后我们把他提交到我们的版本库 运行 1git add index.php 这里有时候在提交某些文件的时候 会出现一些提示 git使用了liunx下的换行模式 关掉和不关掉都没什么大碍 我这边是把他关了 因为看着不舒服 运行 1git config --global core.autocrlf false 然后我们把他提交到版本库中 运行 -m后面的内容是本次提交的注释说明 1234$ git commit -m &quot;测试&quot;[master (root-commit) 3d36c15] 测试 1 file changed, 2 insertions(+) create mode 100644 index.php 这里我是运行成功了 因为是之前设置过用户名和邮箱 没有设置过的需要运行 12git config --global user.name &quot;wangyiming-666” git config --global user.email &quot;2312892231@qq.com” 然后再运行一遍下面的代码 就可以成功了 1$ git commit -m &quot;测试&quot; ****下面讲一下git的版本信息 以及版本回退操作我们可以修改一下index.php的文件 123&lt;?phpecho \"现在的时间是:\".date('Y-m-d H:i:s');echo \"我又多出了一行代码呦!\"; 然后我们运行 如下代码 1git status 执行如下 1234567On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: index.phpno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 要想查看本次修改的内容 执行 1git diff 执行结果如下 1234567891011diff --git a&#x2F;index.php b&#x2F;index.phpindex d149374..f90d6d7 100644--- a&#x2F;index.php+++ b&#x2F;index.php@@ -1,2 +1,3 @@ &lt;?php-echo &quot;现在的时间是:&quot;.date(&#39;Y-m-d H:i:s&#39;);\\ No newline at end of file+echo &quot;现在的时间是:&quot;.date(&#39;Y-m-d H:i:s&#39;);+echo &quot;我又多出了一行代码呦!&quot;;\\ No newline at end of file 然后我们把本次修改的内容提交到版本库中把 依次运行 123git add index.php git status &#x2F;&#x2F;查看文件状态git commit -m “加了一行哦！” 运行结果如下 12[master 1039ae7] 加了一行代码哦！ 1 file changed, 2 insertions(+), 1 deletion(-) 我们可以查看我们的历史版本 运行 1git log 运行结果如下 1234567891011commit 1039ae7972f4b054b204cbfaf7639b265483302f (HEAD -&gt; master)Author: wangyiming-666 &lt;2312892231@qq.com&gt;Date: Thu Feb 27 21:48:54 2020 +0800 加了一行代码哦！commit 3d36c1521e52f03dcd1fba16c073904fdf80ba5eAuthor: wangyiming-666 &lt;2312892231@qq.com&gt;Date: Thu Feb 27 21:10:34 2020 +0800 测试 有了版本日志 我们就可以回退到以前的版本了 运行 1git reset --hard 版本号 &#x2F;&#x2F;就是上面的commit 输入前几个数字即可","path":"2020/10/19/git的简单使用/","date":"10-19","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2020/10/19/hello-world/","date":"10-19","excerpt":"","tags":[]},{"title":"ajax传文件的注意点","text":"1、在ajax表单传文件html注意点123456&lt;form action=\"http://localhost:8080\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\" value=\"\" /&gt;&lt;br&gt; &lt;input type=\"text\" id=\"password\" name=\"password\" value=\"\" /&gt;&lt;br&gt; &lt;input type=\"file\" name=\"\" id=\"img\" value=\"\" /&gt; &lt;input type=\"submit\" id=\"btn\" value=\"登录\" /&gt; &lt;/form&gt; 2、js中的注意点1234567891011121314151617181920212223$(function () &#123; $('form').on('submit', function () &#123; let name = $('#username').val() let pwd = $('#password').val() let file = $(\"#img\")[0].files[0]; let formData = new FormData() formData.append('name', name) formData.append('pwd', pwd) formData.append('img', file) console.log(formData); $.ajax(&#123; url: \"http://localhost:8080\", type: \"post\", data:formData, contentType: false, processData: false, success: function (data) &#123; &#125; &#125;); return false &#125;) &#125;) 在jquery中注意要添加这两个属性否则图片传不到后端服务器 12contentType: false,processData: false, 使用formdata属性更好的配合文件上传 1234567let name = $('#username').val() let pwd = $('#password').val() let file = $(\"#img\")[0].files[0]; let formData = new FormData() formData.append('name', name) formData.append('pwd', pwd) formData.append('img', file)","path":"2020/10/19/ajax传文件的注意点/","date":"10-19","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"vue数据双向绑定原理","text":"1、Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 1&lt;input type=\"text\" id=\"ipt\"&gt; 12345678910111213141516let obj = &#123;&#125; let temp let ipt = document.querySelector('#ipt') ipt.oninput = function () &#123; obj.name = this.value &#125; Object.defineProperty(obj, 'name', &#123; get() &#123; return temp &#125;, set(newVal) &#123; temp = newVal ipt.value = newVal &#125; &#125;) 当获取obj属性的时候回传入get方法 当获取obj属性的时候回传入set方法 利用这个特性 把表单数据和对象中的数据进行双向绑定 运行结果如下","path":"2020/10/19/vue数据双向绑定原理/","date":"10-19","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"thinkphp常量","text":"1、加载静态资源的路径ROOT：项目目录 STATIC ：项目目录下的static目录 JS ：项目目录下的static/js目录 CSS：项目目录下的static/css目录 我们可以用view模板打印这些常量的具体路径 输出效果如下 打开application文件夹下的config文件，可根据你自己需要自定义资源常量，定义好后常量就可以在模板文件中使用常量了。 例如： 2、预定义常量预定义常量是指系统内置定义好的常量，不会随着环境的变化而变化，包括： EXT 类库文件后缀（.php） THINK_VERSION 框架版本号 3、路径常量系统和应用的路径常量用于系统默认的目录规范，可以通过重新定义改变，如果不希望定制目录，这些常量一般不需要更改。 123456789101112131415161718192021222324252627DS 当前系统的目录分隔符THINK_PATH 框架系统目录 ROOT_PATH 框架应用根目录APP_PATH 应用目录（默认为application）CONF_PATH 配置目录（默认为APP_PATH）LIB_PATH 系统类库目录（默认为 THINK_PATH.'library/'）CORE_PATH 系统核心类库目录 （默认为 LIB_PATH.'think/'）TRAIT_PATH 系统trait目录（默认为 LIB_PATH.'traits/'）EXTEND_PATH 扩展类库目录（默认为 ROOT_PATH . 'extend/')VENDOR_PATH 第三方类库目录（默认为 ROOT_PATH . 'vendor/'）RUNTIME_PATH 应用运行时目录（默认为 ROOT_PATH.'runtime/'）LOG_PATH 应用日志目录 （默认为 RUNTIME_PATH.'log/'）CACHE_PATH 项目模板缓存目录（默认为 RUNTIME_PATH.'cache/'）TEMP_PATH 应用缓存目录（默认为 RUNTIME_PATH.'temp/'） 4、系统常量系统常量会随着开发环境的改变或者设置的改变而产生变化。 123456789IS_WIN 是否属于Windows 环境 IS_CLI 是否属于命令行模式 THINK_START_TIME 开始运行时间（时间戳）THINK_START_MEM 开始运行时候的内存占用ENV_PREFIX 环境变量配置前缀","path":"2020/03/01/thinkphp常量/","date":"03-01","excerpt":"","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"composer的基本用法","text":"composer类似于nodejs的npm 在安装php的包之前 还需要检索在packagist资源库中检索一下包的存在 运行 1composer search phpmailer 检索结果如下 12345678910111213phpmailer/phpmailer PHPMailer is a full-featured email creation and transfer class for PHPswiftmailer/swiftmailer Swiftmailer, free feature-rich PHP mailerphpmailer/phpmailer PHPMailer is a full-featured email creation and transfer class for PHPvernes/yiimailer Yii extension for sending emails with layouts using PHPMaileritinerisltd/wp-phpmailer WP PHPMailer provides a clean and simple way to configure WordPress-bundled PHPMailer library, allowing you to quickly get started sending mail through a local or cloud based service of your choice.msp/smtp SMTP with PHPMailerzyx/zyx-phpmailer PHPMailer integration for Yii 2 frameworkfilips123/monolog-phpmailer PHPMailer handler for Monologyurunsoft/phpmailer-swoole PHPMailer 支持 Swoole 协程环境yuan1994/tp-mailer A powerful and beautiful php mailer for All of ThinkPHP and Other PHP Frameworks based SwiftMailerrmrevin/yii2-postman Mail module for Yii2.locomotivemtl/charcoal-email Email sending and queueing for Charcoaldappur/framework A stylish PHP application framework crafted using Slim, Twig, Eloquent and Sentinel designed to get you from clone to production in a matter of minutes.byjg/mailwrapper A lightweight wrapper for send mail. The interface is tottaly decoupled from the sender. The sender availables are: PHP Mailer, AWS SES Api, Mandril Api.phpmailerflamin/phpmailer PHPMailer Editado para menos arquivos 我们可以发现有很多phpmailer的提供商 然后我们就可以执行安装啦 运行 1composer require phpmailer&#x2F;phpmailer 如果出现如下结果说明安装成功 12345678910Using version ^6.1 for phpmailer&#x2F;phpmailer.&#x2F;composer.json has been updatedLoading composer repositories with package informationphpmailer&#x2F;phpmailer suggests installing psr&#x2F;log (For optional PSR-3 debug logging) phpmailer&#x2F;phpmailer suggests installing league&#x2F;oauth2-google (Needed for Google XOAUTH2 authentication)phpmailer&#x2F;phpmailer suggests installing hayageek&#x2F;oauth2-yahoo (Needed for Yahoo XOAUTH2 authentication)phpmailer&#x2F;phpmailer suggests installing stevenmaguire&#x2F;oauth2-microsoft (Needed for Microsoft XOAUTH2 authentication)phpmailer&#x2F;phpmailer suggests installing symfony&#x2F;polyfill-mbstring (To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2))Writing lock fileGenerating autoload files 这里我们可以看到根目录下生成了许多文件 我们可以大概了解一下 通过自动加载文件我们就可以引入我们安装的包了 在根目录下新建一个index.php 我们可以在index文件引入一下 代码如下 1234567&lt;?php//引入自动加载文件require __DIR__.'/vendor/autoload.php';// 实例化PHPmailer对象$mailer = new \\PHPMailer\\PHPMailer\\PHPMailer();//打印看一下吧var_dump($mailer); 部分输出如下 1object(PHPMailer\\PHPMailer\\PHPMailer)#3 (74) &#123; [&quot;Priority&quot;]&#x3D;&gt; NULL [&quot;CharSet&quot;]&#x3D;&gt; string(10) &quot;iso-8859-1&quot; [&quot;ContentType&quot;]&#x3D;&gt; string(10) &quot;text&#x2F;plain&quot; [&quot;Encoding&quot;]&#x3D;&gt; string(4) &quot;8bit&quot; [&quot;ErrorInfo&quot;]&#x3D;&gt; string(0) &quot;&quot; [&quot;From&quot;]&#x3D;&gt; string(14) &quot;root@localhost&quot; [&quot;FromName&quot;]&#x3D;&gt; string(9) &quot;Root User&quot; [&quot;Sender&quot;]&#x3D;&gt; string(0) &quot;&quot; [&quot;Subject&quot;]&#x3D;&gt; string(0) &quot;&quot; [&quot;Body&quot;]&#x3D;&gt; string(0) &quot;&quot; [&quot;AltBody&quot;]&#x3D;&gt; string(0) &quot;&quot; [&quot;Ical&quot;]&#x3D;&gt; string(0) &quot;&quot; [&quot;MIMEBody&quot;:protected]&#x3D;&gt; string(0) &quot;&quot; composer.json 和 composer.lock 两个文件 composer.json的内容如下 12345&#123; \"require\": &#123; \"phpmailer/phpmailer\": \"^6.1\", &#125;&#125; 可以看到require定义了要引入的包名和版本号 其中包含了命名包的机制 如果我们引入了phpmailer/phpmailer包 发现还要一个包 xxx/phpmailer中的一个功能 就可以在require里面填入啦 我们一般都需要安装的是稳定版 （stable） 开发版本为（dev） 我们可以在composer.json中添加以下配置项 1\"minimum-stability\": \"stable\" 接下来我们就手动安装一个包吧 手动更新composer.json 123456789&#123; \"require\": &#123; \"phpmailer/phpmailer\": \"^6.1\", \"phpoffice/phpspreadsheet\": \"^1.10\", &#125;, \"minimum-stability\": \"stable\"&#125;//然后后运行composer install 就可以看到安装的过程啦！ composer.lock 中说明的安装的具体的版本号 在提交项目的适合要把它和composer.json 一起提交上去哦！ 下面我们可以自己制作一个包 首先我们在github上面创建一个空仓库 命名为http 然后创建http文件夹 并下面初始化一个composer.json文件 运行 1composer init 如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 Welcome to the Composer config generator This command will guide you through creating your composer.json config.&#x2F;&#x2F;填写供应商和包名 格式：供应商&#x2F;包名Package name (&lt;vendor&gt;&#x2F;&lt;name&gt;) [һ&#x2F;http]: wangyiming-666&#x2F;http&#x2F;&#x2F;包的描述 也可以不填Description []: curl http&#x2F;&#x2F;github的用户名和邮箱Author [wangyiming-666 &lt;2312892231@qq.com&gt;, n to skip]: wangyiming-666 &lt;2312892231@qq.com&gt;&#x2F;&#x2F;发布包的最低要求 dev可以和github同步 stable则需要打tag标签蔡锷可以发布Minimum Stability []: stable&#x2F;&#x2F;默认library即可Package Type (e.g. library, project, metapackage, composer-plugin) []: library&#x2F;&#x2F;授权类型可以不同License []: MITDefine your dependencies.是否定义当前依赖项Would you like to define your dependencies (require) interactively [yes]? y&#x2F;&#x2F;选择依赖包phpSearch for a package: php&#x2F;&#x2F;这里yesWould you like to define your dev dependencies (require-dev) interactively [yes]? y&#x2F;&#x2F;然后phpSearch for a package: php&#x2F;&#x2F;输入最低版本约束Enter the version constraint to require (or leave blank to use the latest version): &gt;&#x3D;5.3&#x2F;&#x2F;预览如下Search for a package: &#123; &quot;name&quot;: &quot;wangyiming-666&#x2F;http&quot;, &quot;description&quot;: &quot;curl http&quot;, &quot;type&quot;: &quot;library&quot;, &quot;require-dev&quot;: &#123; &quot;php&quot;: &quot;&gt;&#x3D;5.3&quot; &#125;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;wangyiming-666&quot;, &quot;email&quot;: &quot;2312892231@qq.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;stable&quot;, &quot;require&quot;: &#123;&#125;&#125;&#x2F;&#x2F;是否创建composer.json 选yesDo you confirm generation [yes]? yWould you like to install dependencies now [yes]? yLoading composer repositories with package informationUpdating dependencies (including require-dev)Nothing to install or updateWriting lock fileGenerating autoload files 然后为了方便自动加载文件 我们在composer.json内还应该配置映射类库的命名空间的实际目录 12345\"autoload\": &#123; \"psr-4\": &#123; \"wangyiming\\\\http\\\\\": \"src/http/lib\" &#125; &#125; 然后我们在根目录下面创建路径为src/http/lib/Http.php的文件 代码如下 1234567891011121314151617&lt;?phpnamespace wangyiming\\http;/** * HTTP 请求操作类 * Class Http * @package xiaokeai\\http */class Http&#123; /** * GET请求类 * @param $url * @return bool|string */ public static function requestByGet($url)&#123; return file_get_contents($url); &#125;&#125; 然后我们要建立与composer的关系，加入到自动加载机制（aotuload）中去 运行 1composer install 运行结果如下 123456D:\\phpStudy\\WWW\\http&gt;composer install Loading composer repositories with package information Updating dependencies (including require-dev) Nothing to install or update Writing lock file Generating autoload files 然后我们就可以看到在verndor/composer/autoload_psr4. php 文件中记录了$vendorDir 和 $baseDir 的路径。使用 Composer 安装类库依赖时， Packagist 会自动将自定义的项目文件 放到 vendor 目录下。 可以看到文件内容如下了 12345678910&lt;?php// autoload_psr4.php @generated by Composer$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array( 'wangyiming\\\\http\\\\' =&gt; array($baseDir . '/src/http/lib'),); 我们可以在本地测试一下这个包 在跟目录下创建index.php 代码如下 123&lt;?phprequire __DIR__.'/vendor/autoload.php';var_dump(strlen(wangyiming\\http\\Http::requestByGet('http://baidu.com'))); 然后在浏览器运行 会得到如下结束 说明运行成功 1int(81) 然后推送文章到github 这里不宅说明 可以看以前的文章 git的简单使用 然后我们要拥有一个packagist账号并登录 访问地址：点这里 ， 实现注册和登录操作，不过也可以使用第三 方，如 GitHub 账号实现授权登录，简化注册流程。 提交包的 GitHub 仓库地址 访问地址：点这里， 在 Repository URL (Git/Svn/Hg）下方 的输入框中，填写 Git 地址后单击 Check 按钮 然后就点submit就可以提交啦！ 当 Composer 获取测试版本（dev）进行依赖包安装时， 会自动同步 GitHub 上最新的 代码，但稳定版（stable）的发布需要在 GitHub 上添加相应的标签（Tag）。下面简单讲 解操作步骤。 我们可以在本地创建一个tag 然后再推送上去 运行下面的命令创建tag 12345git tag -a v1.0.0 -m&#39;v1.0.0&#39;&#x2F;&#x2F;运行如下命名可以查看tag是否添加成功git tag&#x2F;&#x2F;执行结果如下v1.0.0 然后我们把tag推送 执行 12345678git push http --tags&#x2F;&#x2F;执行结果如下Enumerating objects: 1, done.Counting objects: 100% (1&#x2F;1), done.Writing objects: 100% (1&#x2F;1), 158 bytes | 158.00 KiB&#x2F;s, done.Total 1 (delta 0), reused 0 (delta 0)To https:&#x2F;&#x2F;github.com&#x2F;wangyiming-666&#x2F;http.git * [new tag] v1.0.0 -&gt; v1.0.0 然后点击update 会发现版本已经更新 现在我们测试一下自己的包 在一个新的文件夹下面运行 12345678910composer composer require wangyiming-666&#x2F;http&#x2F;&#x2F;出现下面结果说明已经正常安装了$ composer require wangyiming-666&#x2F;httpUsing version ^1.0 for wangyiming-666&#x2F;http.&#x2F;composer.json has been updatedLoading composer repositories with package informationUpdating dependencies (including require-dev)Package operations: 1 install, 0 updates, 0 removals - Installing wang] ialin&#x2F;http (vl.0 . 0) : Loading from cache Writing lock file Generat工ng autoload files 然后我们根据测试的时候一样 再测试一遍就可以啦！","path":"2020/02/29/composer/","date":"02-29","excerpt":"","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"thinkphp5命令行操作","text":"在引入tinkphp5的时候推荐使用Composer安装 执行 1composer create-project topthink&#x2F;think tp 5.0.* --prefer-dist cd到tp5目录下 运行 1php think 执行结果如下 12345678910111213141516171819202122232425262728Think Console version 0.1Usage: command [options] [arguments]Options: -h, --help Display this help message -V, --version Display this console version -q, --quiet Do not output any message --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debugAvailable commands: build Build Application Dirs clear Clear runtime file help Displays help for a command list Lists commands session Clear Seesion file make make:controller Create a new resource controller class make:model Create a new model class optimize optimize:autoload Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production. optimize:config Build config and common file cache. optimize:route Build route cache. optimize:schema Build database schema cache. 可以看到框架提供了很多操作命令 最基本的生成模块命令 先把根目录下的bulid.php打开 里面提供的生成模块的示例命令 我们在application目录下面也创建一个build.php，文件内容如下 123456789101112131415&lt;?phpreturn [ // 生成应用公共文件 '__file__' =&gt; ['common.php', 'config.php', 'database.php'], // 定义demo模块的自动生成 （按照实际定义的文件名生成） 'demo' =&gt; [ '__file__' =&gt; ['common.php'], '__dir__' =&gt; ['behavior', 'controller', 'model', 'view'], 'controller' =&gt; ['Index', 'Test', 'UserType'], 'model' =&gt; ['User', 'UserType'], 'view' =&gt; ['index/index'], ], // 其他更多的模块定义]; 然后运行 1php think bulid 可以看到在application目录下面demo模块已经自动完成 下面是生成控制器和模型文件 12php think make:controller demo&#x2F;Order &#x2F;&#x2F;生成控制器php think make:model demo&#x2F;Order &#x2F;&#x2F;生成模型 生成控制器的时候 默认是资源控制器 自带初始化方法 这里我们也可以创建一个空的控制器 运行 1php think make:controller demo&#x2F;Order --plain 下面讲一下如何扩展命令行的功能 在application下创建一个command目录 里面新增一个Session.php文件 然后里面的代码如下 12345678910111213141516171819202122232425262728&lt;?phpnamespace app\\command;use think\\console\\Command;use think\\console\\Input;use think\\console\\input\\Option;use think\\console\\Output;class Session extends Command&#123; protected function configure() &#123; // 设置命令名字和额外选项和描述信息 $this-&gt;setName('session') -&gt;addOption('clear','d',Option::VALUE_NONE,'clear all session',null) -&gt;setDescription('Clear Seesion file'); &#125; // 指令操作 protected function execute(Input $input, Output $output) &#123; // 获取指令选项名称 $path = $input-&gt;getOption('clear'); if($path)&#123; unset($_SESSION); $output-&gt;writeln(\"Clear Session Successed\"); &#125;else&#123; $output-&gt;writeln(\"Clear Nothing\"); &#125; &#125;&#125; configure方法定义了命令的 名称，选项，功能描述 可以看出 这里的setName定义了这个指令的名字 addOption定义了这个指令的其他选项 其中的： clear 是选项的名字 d 对应是别名 Option对应选项的类型 值对应没有输入值 CVALUE_NONE） 、输入值必须 CVALUE _REQUIRED）、输入值可选（VALUE_OPTIONAL）和数组输入值（VALUE IS ARRAY) 4 种。 ‘clear all session’对应选项的的说明 null：默认值，没有的话就默认为null execute 方法定义了具体功能 然后在application目录下面的command.php(没有的话需要创建) 添加下面的代码 123return [ 'app\\command\\Session',]; 然后运行php think 看一下是否注册成功 出现如下说明成功了 123456Available commands: build Build Application Dirs clear Clear runtime file help Displays help for a command list Lists commands session Clear Seesion file 然后我们可以测试一下 运行 12345678910111213php think session --clear&#x2F;&#x2F;结果为Clear Session Successed&#x2F;&#x2F;也可以使用别名php think session --d&#x2F;&#x2F;结果为Clear Session Successed&#x2F;&#x2F;如果输入指令无php think session&#x2F;&#x2F;结果为Clear Nothing","path":"2020/02/28/thinkphp/","date":"02-28","excerpt":"","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"Node Stream","text":"所有的stream都是EventEmitter的实例 意味着stream可以使用事件的所有方法 data：每次读取都会产生这个事件，取到部分流（chunk）到数据 end：读取完会产生的事件 首先创建一个对象使用对象的createReadStream( )方法 12var fs = require(\"fs\");var rs = fs.createReadStream(\"abc.txt\"); 然后声明一个变量存储提取的次数counter 123456789var counter = 0;rs.on(\"data\",function(chunk)&#123;counter++;console.log(\"弟\"+counter+\"次取数据\",chunk);&#125;)rs.on(\"end\",function()&#123; console.log(\"done.....\");&#125;) 对于on data事件的这样理解的 因为所有流都是事件的实例 所有不需要实例化 Events对象 直接使用 data事件回调函数里面显示每次取得数据 每次最大读取64kb end事件显示读取完后运行的代码 运行结果如下： 12345弟13取数据 &lt;Buffer 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 ... 65486 more bytes&gt;弟14取数据 &lt;Buffer 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 ... 65486 more bytes&gt;弟15取数据 &lt;Buffer 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 ... 65486 more bytes&gt;弟16取数据 &lt;Buffer 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 ... 65486 more bytes&gt;done..... 文件的可写流 单次最大写入16384字节 首先调用fs的可写流方法 12var fs = require(\"fs\");var ws = fs.createWriteStream(\"abc.txt\"); 然后写入数据 12345678910ws.write(\"abc\",function(err)&#123;if(err)console.log(err)else console.log(\"write\");&#125;)console.log(ws.writableHighWaterMark);ws.end(\"写完了\")ws.on(\"finish\",function()&#123; console.log(\"done\");&#125;) end事件代表写完的标志 如果没有这个标志那么文件会在写到16384字节 并且会在写的文件的最后加入“写完了” finish事件是在文件写完后运行的代码 运行结果如下 1234$ node 文件可写流.js16384writedone 文件内容 1abc写完了 关于pipe（） 类似于一个管道 在数据特别大的时候会用得到 1234567var fs = require(\"fs\");var rs = fs.createReadStream(\"abc.txt\");var ws = fs.createWriteStream(\"1M.txt\");ws.on(\"pipe\",function(src) &#123; console.log(\"有数据在流动\");&#125;)rs.pipe(ws) 运行效果如下 12$ node 管道.js有数据在流动","path":"2020/02/28/Stream/","date":"02-28","excerpt":"","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]}],"categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]}