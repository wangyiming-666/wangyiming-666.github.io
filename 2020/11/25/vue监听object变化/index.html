<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="小鸣的PHP"><meta name="renderer" content="webkit"><meta name="copyright" content="小鸣的PHP"><meta name="keywords" content="小鸣的PHP"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>vue监听object变化 · Mr.Wang's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">WYMing</div><div class="profile-signature">for me</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a>Mr.Wang's Blog</a></div><div class="intro-nav-label-box"><a href="/">主页</a><a href="/archives/">归档</a><a href="/tags/">标签</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">主页</a><a href="/archives/">归档</a><a href="/tags/">标签</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">vue监听object变化</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2020-11-25</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="vue源码学习"> vue源码学习</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h3 id="1、关于变化侦测"><a href="#1、关于变化侦测" class="headerlink" title="1、关于变化侦测"></a>1、关于变化侦测</h3><p>​    <strong>vue.js会通过状态自动生成DOM输出页面显示，在这个过程中需要不停的去渲染</strong></p>
<p>​    <strong>react和angular 是通过一种比较暴力的手段  当状态发生变化时 他不知道是否改变了  所以框架内部会通过暴力对比  来对比除那些DOM节点需要重新渲染</strong></p>
<p><strong>vue的变化属于’推‘ 当状态发生改变 向这个状态的所有依赖发送通知</strong></p>
<h3 id="2、如何追踪变化"><a href="#2、如何追踪变化" class="headerlink" title="2、如何追踪变化"></a>2、如何追踪变化</h3><p>​    <strong>在JavaScript中有两种方法可以追踪一个对象的变化  分别是Object.defineProperty和Proxy 那么我们就可写出如下代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//configurable：可配执行</span></span><br><span class="line"><span class="comment">//enumerble：枚举性</span></span><br><span class="line"><span class="comment">//writable:可读写性</span></span><br><span class="line"><span class="comment">//value:数据值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      	enumerble: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>这里把Object.defineProperty进行了封装  只需要传入obj, key, val。当从obj中读取数据时get会被触发 当设置obj的数据时 set会被触发</strong></p>
<h3 id="3、如何收集依赖"><a href="#3、如何收集依赖" class="headerlink" title="3、如何收集依赖"></a>3、如何收集依赖</h3><p>​    <strong>上面我们只是把Object.defineProperty进行了封装 实际并没有什么用处 我们之所以观察数据 目的是当数据发生变化的时候  通知那些曾经使用这些数据的地方</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;hl&gt;(&#123; name &#125;&#125;&lt;&#x2F;hl&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在模板中使用了name  当name发生改变的时候  要向使用它的地方发送通知</strong></p>
<p>​    <strong>那么就是先收集依赖  把所有用到name的地方先收集起来 等属性发生变化的时候  把之前搜集好的依赖触发一遍就好了</strong></p>
<p><strong>就是在getter中收集依赖  在setter中触发依赖</strong></p>
<h3 id="4、依赖收集在哪里"><a href="#4、依赖收集在哪里" class="headerlink" title="4、依赖收集在哪里"></a>4、依赖收集在哪里</h3><p>*<em>每一个key都要有自己的数组，用来储存当前key的依赖 *</em></p>
<p><strong>假设依赖是一个函数，保存在window.target上  现在可把defineReactive函数改造一下</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//configurable：可配执行</span></span><br><span class="line"><span class="comment">//enumerble：枚举性</span></span><br><span class="line"><span class="comment">//writable:可读写性</span></span><br><span class="line"><span class="comment">//value:数据值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> dep = [] <span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      	enumerble: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">          dep.push(<span class="built_in">window</span>.target)<span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//新增</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;dep.length;i++)&#123;</span><br><span class="line">            dep[i](newVal,val)</span><br><span class="line">          &#125;</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>set触发时收集依赖  get触发时循环收集到的依赖并触发</strong></p>
<p><strong>这样写耦合性太大  可以封装一个Dep就可以收集依赖，删除依赖和向依赖发送通知</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">   	emoveSub(sub) &#123;</span><br><span class="line">        remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">    &#125;</span><br><span class="line">    depend() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addSub(<span class="built_in">window</span>.target)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subs.length; i++) &#123;</span><br><span class="line">            subs[i].update()  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = arr.indexOf(item)</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后改造一下defineReactive</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep() <span class="comment">// 修改</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerble: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            dep.depend()<span class="comment">//修改</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal</span><br><span class="line">            dep.notify()<span class="comment">//新增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样我就们可以吧依赖收集到Dep中了</strong></p>
<h3 id="5、依赖是谁"><a href="#5、依赖是谁" class="headerlink" title="5、依赖是谁"></a>5、依赖是谁</h3><p>​    <strong>我们收集的依赖是window.target，那么他到底是什么，换句话说就是当属性发生变化的时候去通知谁</strong></p>
<p>​    <strong>我们要通知的地方有很多，类型也有很多。这时候就需要一个集中来处理这些情况的类，然后我们在依赖搜集阶段只收集这个封装好的类的实例进来，通知就通知他一个，然后由他来通知其他地方，那么我们暂且叫这个类为Watcher</strong></p>
<p><strong>也就可以说我们搜集的window.targe就是Watcher 搜集的依赖也是Watcher</strong></p>
<h3 id="6、什么是Watcher"><a href="#6、什么是Watcher" class="headerlink" title="6、什么是Watcher"></a>6、什么是Watcher</h3><p><strong>Watcher是一个中介角色，数据发生变化时通知他，然后它再通知其他地方。</strong></p>
<p><strong>关于Watcher，先看一个经典的使用方式：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keypath</span></span><br><span class="line">vm.$watch(<span class="string">'a.b.c'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//做点什么</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    <strong>这段代码表示当data.a.b.c属性发生变化时，触发第二个参数中的函数</strong></p>
<p><strong>思考一下，怎么实现这个功能呢？好像只要把这个Watcher实例添加到data.a.b.c属性的Dep中就行了。然后，当data.a.b.c的值发生变化时，通知Watcher。接着，Watcher再执行参数中的这个回调函数。</strong></p>
<p>​    <strong>思考完毕，写出如下代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm,expOrFn,cb)&#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">      <span class="comment">//执行this.getter(),就可以读取data.a.b.c的内容</span></span><br><span class="line">        <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="built_in">window</span>.target = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm,<span class="keyword">this</span>.vm)</span><br><span class="line">        <span class="built_in">window</span>.target = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updated() &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm,<span class="keyword">this</span>.value,oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这段代码可以把自己主动添加到data.a.b.c的Dep中去，是不是很神奇？</strong></p>
<p>​        <strong>因为在get方法中先把window.target设置成了this，也就是当前watcher实例，然后再读一下data.a.b.c的值,这肯定会触发getter。</strong></p>
<p>​    <strong>触发了getter，就会触发搜集依赖的逻辑。而关于收集依赖，上面已经介绍了，会从window.target中读取一个依赖并添加到Dep中。</strong></p>
<p>​    <strong>这就导致，只要先在window.target赋一个this，然后再读一下值，去触发getter，就可以把this主动添加到keypath的Dep中。</strong></p>
<p>​    <strong>依赖注入到Dep中后，每当data.a.b.c的值发生变化时，就会让依赖列表中所有的依赖循环触发update方法，也就是Watcher中的update方法。而update方法会执行参数中的回调函数，将value和oldvalue传到参数中</strong></p>
<p>​    <strong>所以，其实不管用户是执行的vm.$watch(‘a.b.c’,(value,oldvalue)=&gt;{})，还是模板中用到的data，都是通过Warcher来通知自己是否需要发生变化</strong></p>
<p>​    <strong>上面代码中的parsePath是怎么读取一个字符串的keypath的， 下面用一段代码来介绍其实现原理：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bailRE.test(path))&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</span><br><span class="line">    <span class="comment">// console.log(segments);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj1 = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">        <span class="comment">//  console.log(segments[i]);</span></span><br><span class="line">            obj1 = obj[segments[i]]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>可以看到，这其实并不复杂。先将keypath用.分割成数组，然后循环数组一层一层去读数 据，最后拿到的obj就是keypath中想要读的数据。</strong></p>
<h3 id="递归侦测所有key"><a href="#递归侦测所有key" class="headerlink" title="递归侦测所有key"></a>递归侦测所有key</h3><p>​    <strong>现在，其实已经可以实现变化侦测的功能了，但是前面介绍的代码只能侦测数据中的某一个 属性，我们希望把数据中的所有属性(包括子属性)都侦测到，所以要封装一个Observer类。 这个类的作用是将一个数据内的所有属性(包括子属性)都转换成getter/setter的形式，然后去 追踪它们的变化：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* Observer类会附加到每一个被侦测的object上。</span></span><br><span class="line"><span class="comment">	* 一旦被附加上，Observer会将object的所有属性转换为getter/setter的形式</span></span><br><span class="line"><span class="comment">	*来收集属性的依赖，并且当属性发生变化时会通知这些依赖</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	walk会将每一个属性都转换成getter/setter的形式来侦测变化</span></span><br><span class="line"><span class="comment">	*这个方法只有在数据类型为0bject时被调用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    walk(obj)&#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            defineReactive(obj,keys[i],obj[keys[i]])   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//新增，递归子属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            dep.depend()</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            val = newVal</span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>在上面的代码中，我们定义了 Observer类，它用来将一个正常的object转换成被侦测的 objecto</strong></p>
<p><strong>然后判断数据的类型，只有Object类型的数据才会调用walk将每一个属性转换成 getter/setter的形式来侦测变化。</strong></p>
<p>​    <strong>最后，在defineReactive中新增new Observer(val)来递归子属性，这样我们就可以把 data中的所有属性(包括子属性)都转换成getter/setter的形式来侦测变化。</strong></p>
<p><strong>当data中的属性发生变化时，与这个属性对应的依赖就会接收到通知。</strong></p>
<p>​    <strong>也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的 objecto</strong></p>
<h3 id="8、关于object的问题"><a href="#8、关于object的问题" class="headerlink" title="8、关于object的问题"></a>8、关于object的问题</h3><p>​    <strong>前面介绍了 Object类型数据的变化侦测原理，了解了数据的变化是通过getter/setter来追踪 的。也正是由于这种追踪方式，有些语法中即便是数据发生了变化，Vue.js也追踪不到。</strong></p>
<p><strong>比如，向object添加属性：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue((</span><br><span class="line">      el: <span class="string">'#el'</span>,</span><br><span class="line">      template: <span class="string">'#demo-template'</span>,</span><br><span class="line">     methods: &#123;</span><br><span class="line">action () (</span><br><span class="line">          <span class="keyword">this</span>.obj.name = <span class="string">'berwin'</span></span><br><span class="line">       &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">       data:   &#123;</span><br><span class="line">      obj: ()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>​    <strong>在action方法中，我们在obj上面新增了 name属性，Vue.js无法侦测到这个变化，所以不 会向依赖发送通知。</strong></p>
<p><strong>再比如，从。bj中删除一个属性：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">van vm = <span class="keyword">new</span> Vue((</span><br><span class="line">      el: <span class="string">'ttel*,</span></span><br><span class="line">      template: '#demo-template',</span><br><span class="line">      methods: &#123;</span><br><span class="line">action () (</span><br><span class="line">          <span class="keyword">delete</span> <span class="keyword">this</span>.obj.name</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: (</span><br><span class="line">      obj: &#123;</span><br><span class="line">          name: <span class="string">'berwin'</span></span><br><span class="line">      &#125;</span><br><span class="line">      [&#125;](#bookmark1483)</span><br><span class="line">   ))</span><br></pre></td></tr></table></figure>

<p>​    <strong>在上面的代码中，我们在action方法中删除了 obj中的name属性，而Vue.js无法侦测到 这个变化，所以不会向依赖发送通知。</strong></p>
<p>​    <strong>Vue.js通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化, 但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才会导致上 面例子中提到的问题。</strong></p>
<p>​    <strong>但这也是没有办法的事，因为在ES6之前，JavaScript没有提供元编程的能力，无法侦测到 一个新属性被添加到了对象中，也无法侦测到一个属性从对象中删除了。为了解决这个问题， Vue.js提供了两个API  vm.$set与vm.$delete,第4章会详细介绍它们。</strong></p>
<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a><strong>9、总结</strong></h3><p>​    <strong>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</strong></p>
<p>​    <strong>Object可以通过Object.defineProperty将属性转换成getter/setter的形式来追踪变化。 读取数据时会触发getter,修改数据时会触发setter。</strong></p>
<p>​    <strong>我们需要在getter中收集有哪些依赖使用了数据。当setter被触发时，去通知getter中收集的 依赖数据发生了变化。</strong></p>
<p>​    <strong>收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了 Dep,它用来收集依赖、删除 依赖和向依赖发送消息等。</strong></p>
<p><strong>所谓的依赖，其实就是Watcher。只有Watcher触发的getter才会收集依赖，哪个Watcher</strong> </p>
<p>​    <strong>触发了 getter,就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有 的Watcher都通知一遍。</strong></p>
<p>​    <strong>Watcher的原理是先把自己设置到全局唯一的指定位置（例如window.target）,然后读取 数据。因为读取了数据，所以会触发这个数据的gettero接着，在getter中就会从全局唯一的那 个位置读取当前正在读取数据的Watcher,并把这个Watcher收集到Dep中去。通过这样的方式, Watcher可以主动去订阅任意一个数据的变化。</strong></p>
<p>​    <strong>此外，我们创建了 Observer类，它的作用是把一个object中的所有数据（包括子数据） 都转换成响应式的，也就是它会<em>m</em> object中所有数据（包括子数据）的变化。</strong></p>
<p>​    <strong>由于在ES6之前JavaScript并没有提供元编程的能力，所以在对象上新增属性和删除属性都 无法被追踪到。</strong></p>
<p><strong>下图给出了 Data、Observer^ Dep和Watcher之间的关系。</strong></p>
<p><img src="/2020/11/25/vue%E7%9B%91%E5%90%ACobject%E5%8F%98%E5%8C%96/QQ20201125-223143@2x.png" alt="QQ20201125-223143@2x"></p>
<hr>
<p>​    <strong>Data通过Observer转换成了 getter/setter的形式来追踪变化。 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。 当数据发生了变化时，会触发setter,从而向Dep中的依赖（Watcher ）发送通知。</strong></p>
<p>​    <strong>Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有 可能触发用户的某个回调函数等。</strong></p>
</article><!-- lincense--><div class="post-paginator"><a class="nextSlogan" href="/2020/11/06/%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/" title="改变this指向"><span>NextPost ></span><br><span class="nextTitle">改变this指向</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、关于变化侦测"><span class="toc-number">1.</span> <span class="toc-text">1、关于变化侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、如何追踪变化"><span class="toc-number">2.</span> <span class="toc-text">2、如何追踪变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、如何收集依赖"><span class="toc-number">3.</span> <span class="toc-text">3、如何收集依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、依赖收集在哪里"><span class="toc-number">4.</span> <span class="toc-text">4、依赖收集在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、依赖是谁"><span class="toc-number">5.</span> <span class="toc-text">5、依赖是谁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、什么是Watcher"><span class="toc-number">6.</span> <span class="toc-text">6、什么是Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归侦测所有key"><span class="toc-number">7.</span> <span class="toc-text">递归侦测所有key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、关于object的问题"><span class="toc-number">8.</span> <span class="toc-text">8、关于object的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、总结"><span class="toc-number">9.</span> <span class="toc-text">9、总结</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>